'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':1,'href':'/posts/gnome-asia-2020-promote/','title':"그놈 아시아 서밋 2020 (온라인) 개최 ",'section':"News",'content':"번역: 성대현(DaeHyun Sung)\n참고 #  GNOME ASIA 2020 Call for papers is now Open!\nGNOME.Asia Summit 2020 홈페이지\n그놈 아시아 2020 발표 제안이 열렸습니다 #  그놈 아시아 서밋 2020(GNOME.Asia Summit 2020)에서 이 글을 보시는 분들에게 발표자로 참여하도록 초대합니다. 컨퍼런스는 2020년 11월 24일부터 26일, 3일간 열립니다.\n발표 제안은 다음의 링크에서 제출하시면 됩니다. https://events.gnome.org/event/24/abstracts/\n코로나19(COVID-19)의 전 세계적인 확산으로, 모든 회의가 온라인으로 진행 될 예정입니다.\n그놈 아시아 서밋(GNOME.Asia Summit)은 아시아에서 개최되는 연례 그놈 컨퍼런스입니다. 주로 GNOME 데스크탑에 초점을 맞추지만, 응용소프트웨어와 플랫폼 개발 도구도 다룹니다. 이번 서밋에서는 아시아의 그놈 커뮤니티를 한데 모아, 사용자, 개발자, 재단 리더, 정부 및 기업이 현재 기술과 미래 개발에 대해 논의할 수 있는 포럼을 제공합니다.\n가능한 주제는 다음과 같으며,이에 국한되지 않습니다\n 그놈에 기여하기 UI 디자인 접근성 인간 인터페이스 공학 (아이콘과 그래픽 디자인) 마케팅/참여 임베디드 시스템 또는 개방형 하드웨어에서 그놈 개발  리눅스 및 자유 오픈소스 소프트웨어에 기여하기\n 리눅스 커널 및 개발 오픈소스 운영 체제의 개발과 홍보 데비안, 페도라, 오픈수세, 우분투, FreeBSD 및 기타 배포판에 대하여 기타 오픈소스 프로젝트의 개발 및 홍보  위의 목록에 나열되지 않은 자유 오픈소스 소프트웨어에 관한 다른 주제에도 관심이 있습니다.\n다음에 소개되는 세션 종류 중에서 선택할 수 있습니다:\n세션은 25분 및 50분으로 예정되어 있습니다(질의응답 포함). 세션은 기술 발표, 패널 토론 또는 BOF가 될 수 있습니다. 더 많은 시간이 필요하거나 추가 리소스가 필요하면, 언제든지 조직위원회에 문의하십시오.\n제출기준 #  발표 제안에 대한 간단한 요악(약, 200 낱말 이하)으로 제안해주세요. 발표에 대한 정보인 이름, 인물 정보, 제목과 설명을 포함해야 합니다. 그리고, 발표 제안을 다음의 링크 https://events.gnome.org/event/24/abstracts/ 로 제출하시기 바랍니다. 발표심사팀에서 제출된 제안과 가능한 일정을 기준으로 발표 제안을 평가합니다.\n발표 제안 제출기한: 2020년 10월 25일\n추가. 2020년 10월 9일에 GNOME.Asia 운영진 측에게 10월 25일까지 연장되었다고 합니다. 정확한 내용은 다음의 링크를 참조하기 바랍니다 https://www.facebook.com/groups/gnome.asia/permalink/10158709107164183\n만약에, 온라인으로 본인의 자유오픈소스 역량을 발표하실 분은 도전해주시기 바랍니다!\n"});index.add({'id':2,'href':'/posts/new-gnome-kr-site/','title':"그놈 한국 사이트 개편 안내",'section':"News",'content':"지금까지 구글 사이트를 통해 그놈 한국 웹사이트를 제공했는데, 이번에 새롭게 자체 홈페이지를 구축했습니다.\n이전 사이트를 계속 접속 가능합니다.\n https://sites.google.com/site/gnomekr/home  고맙습니다.\n"});index.add({'id':3,'href':'/posts/archive_2001_0804_linux_programing_by_example/','title':"Linux Programming by example",'section':"News",'content':"출처\n 글쓴이 : 키눅스 (2001년 08월 04일 오후 12:57) 읽은수: 319 [ 문서 / 책소개 ] 제목 : Linux Programming by Example 저자 : Wall Kurt 출판사 : Que  제가 표지 디자인을 무척 맘에 들어하는 책입니다. 그동안 사놓고 보지 않고 있다가.. 어제부터 보기 시작했는데.. 내용이 정말 좋더군요. C 언어를 어느정도 아신다면 리눅스 프로그래밍에 대한 개념및 실전 응용을 하는데 많은도움이 될 것 같습니다.(원서지만 영어도 그리 어렵지 않게.. 쉽게 읽어갈수 있습니다.)\n이 책은 C언어를 중심으로 설명하고 있어 리눅스 시스템 프로그래밍과 어플리케이션 개발의 특화된 리눅스 프로그래밍 관련 지식이 없더라도 쉽게 접근할 수 있다.\nhttp://www.wowbook.com/computer/book/info/book_detail.asp?isbn=ISBN0-7897-2215-1\n(출판사와 서점과는 아무 관계가 없읍니다.)\n프로그램세계 2000년 2월호 에서의 리뷰 #  주로 GNU 개발 툴, 시스템 프로그래밍, 리눅스에서의 파일 처리, 인터프로세스 통신, 네트워크 프로그래밍과 애플리케이션 인터페이스, X윈도우 프로그래밍, 디버깅과 메모리 관리, 소프트웨어 버전 컨트롤 및 배포에 관한 주제들을 다룬다.\n총 6부 22장으로 구성된 이 책은 1부에서 리눅스 프로그래밍 환경에 대한 제반 사항과 GNU make를 사용한 프로세스 생성 및 컨트롤 등을 설명하고 있다. 2부에서는 시스템 프로그래밍에 대한 내용으로 프로세스, 시그널, 시스템 호출, 고급 파일 처리 기법 등에 대해 예제 프로그램을 기반으로 설명한다. 3부에서는 리눅스 API와 관련된 주제로 데이터베이스 API, ncurses로 화면 조작, 고급 ncurses 프로그래밍, 사운드 API 등에 대해 기술하고, 4부에서는 파이프와 FIFO, 메모리 공유, 세마포어와 메시지 큐 등 인터프로세스 통신에 대한 내용을 설명하고 있다. 5부와 6부에서는 리눅스 프로그래밍 유틸리티로 디버깅 툴을 사용하는 방법, 소프트웨어 분산, 소스 코드 변환 추적 등에 대해 \u0026lsquo;Music CD 데이터베이스\u0026rsquo;라는 프로젝트를 통해 실습하고 있다.\n전체적으로 리눅스 환경에서 빠르게 프로그래밍 작업을 하는데 필요로 하는 것을 예제를 중심으로 기본기에 입각하여 제시하고 있는 책으로 강력한 리눅스 OS를 개발할 수 있도록 리눅스 프로그래밍의 환경을 사용자 정의 양식으로 조정할 수 있는 힘을 부여하고 있다. 이 책은 C언어를 중심으로 설명하고 있어 리눅스 시스템 프로그래밍과 어플리케이션 개발의 특화된 리눅스 프로그래밍 관련 지식이 없더라도 쉽게 접근할 수 있다.\n주로 GNU 개발 툴, 시스템 프로그래밍, 리눅스에서의 파일 처리, 인터프로세스 통신, 네트워크 프로그래밍과 애플리케이션 인터페이스, X윈도우 프로그래밍, 디버깅과 메모리 관리, 소프트웨어 버전 컨트롤 및 배포에 관한 주제들을 다룬다.\n총 6부 22장으로 구성된 이 책은 1부에서 리눅스 프로그래밍 환경에 대한 제반 사항과 GNU make를 사용한 프로세스 생성 및 컨트롤 등을 설명하고 있다. 2부에서는 시스템 프로그래밍에 대한 내용으로 프로세스, 시그널, 시스템 호출, 고급 파일 처리 기법 등에 대해 예제 프로그램을 기반으로 설명한다. 3부에서는 리눅스 API와 관련된 주제로 데이터베이스 API, ncurses로 화면 조작, 고급 ncurses 프로그래밍, 사운드 API 등에 대해 기술하고, 4부에서는 파이프와 FIFO, 메모리 공유, 세마포어와 메시지 큐 등 인터프로세스 통신에 대한 내용을 설명하고 있다. 5부와 6부에서는 리눅스 프로그래밍 유틸리티로 디버깅 툴을 사용하는 방법, 소프트웨어 분산, 소스 코드 변환 추적 등에 대해 \u0026lsquo;Music CD 데이터베이스\u0026rsquo;라는 프로젝트를 통해 실습하고 있다.\n"});index.add({'id':5,'href':'/docs/develop/architecture/','title':"Architecture",'section':"Develop",'content':"그놈(GNOME) 플랫폼 아키텍쳐 개관 #  이 문서는 그놈 플랫폼에서 사용하는 구조/기술들에 대한 내용을 다루게 됩니다. 아래의 내용을 바탕으로, 전체적인 그놈 데스크탑 환경의 배경이 되는 아키텍쳐를 이해하여 사용자/어플리케이션 개발자들이 어떠한 방향으로 접근해나가야 할 것인지에 대한 사항을 다루게 됩니다.\nGTK+ #  GTK+ 는 그놈이 사용하는 기본 위젯 툴킷(base widget toolkit, 주: 버튼, 스크롤바, 입력창등이 위젯에 해당합니다) 라이브러리 입니다. 원래 GIMP 프로젝트로부터 파생되었고, 대부분의 코드는 C로 작성되었지만 수많은 언어 바인딩을 지원, C++, Python, JavaScript, Rust 등에서도 사용할 수 있습니다.\nGlib #  GLib 라이브러리는, C 언어에서 보다 더 편리한 기능적 요소를 제공해주고 있습니다. GLib은 GTK+ 를 포함, 그놈 프로젝트의 많은 프로그램 구석구석에서 사용됩니다. 그놈에서는 GLib을 사용하는 것으로 다음의 4가지 기능을 얻을 수 있었습니다.\n첫째, 이식성(Portability)입니다. 예를 들어 보자면, 몇몇 C 라이브러리에서는 제공하지만, 또 다른 몇몇 C 라이브러리에서 제공하지 않는 함수들을 제공합니다. 예를 들어볼까요? GLib에는 g_ascii_strcasecmp() 와 g_memmove() 같은 함수가 있습니다. 같은 기능을 하는 함수가 glibc에도 있습니다. strcasecmp() 와 memmove() 가 똑같은 기능을 제공합니다. 만약 기본 C 라이브러리로 glibc를 사용하는 플랫폼이라면 g_ascii_strcasecmp() 와 g_memmove()를 호출시 glibc로 구현되어 있는 함수의 wrapper 역할을 하게 될테지만, 저런 함수를 제공하지 않는 C 라이브러리를 사용하는 플랫폼이라면, 앞의 두 함수를 호출 시 GLib에서 이식성있게 새로 구현해놓은 코드를 사용하게 합니다. 이런 라이브러리를 사용하는 것으로, 프로그래머가 여러가지 플랫폼을 위해 신경쓰는 일을 줄여줄 수 있습니다.\n둘째, GLib은 몇몇 특정 함수를 통해 C를 더욱 편리하게 쓸 수 있게 해줍니다. 예를 들어볼까요? GLib의 날짜 관련 함수 중에, g_date_set_parse() 라는게 있습니다. 흔히 일반적이라고 생각하는 날짜 기록방식대로 문자열을 만들어 던져주면, 로케일 등을 따져서 날짜를 내부에서 사용하기 편한 자료 구조로 만들어줍니다. 그 밖에도, 문자열을 다루거나, 로그 나 디버그 메시지 출력 / 관리에 대해 유연하게 처리할 수 있게 해줍니다.\n세번째로는 제너릭한 자료 구조를 GLib에서 제공받을 수 있습니다. Linked List 라던지, 해시 테이블, Balanced 2진 트리, 가변 배열과 같이 비교적 정형화된 자료 구조를 사용하기 위해 바닥부터 코드를 만들 필요가 없다는 장점이 생깁니다. GLib에서 제공해주는 함수만으로도, 해당 자료 구조를 자유롭게 수정, 추가, 삭제, 탐색할 수 있습니다. 조건에 따라 변화할 수 있는 해시 테이블 같은 자료 구조는, 자기가 원하는 행동을 담은 콜백 함수를 연결할 수 있는 정형화된 인터페이스를 제공해줍니다.\n마지막으로는 GLib main loop를 네번째로 들었는데, 이 추상적인 단어는 확장성이 충분히 고려된 이벤트 loop을 정형화된 형태로 제공한다는 것을 의미한다고 설명드릴 수 있습니다. 타이머라던지, 입출력 콜백, 그리고 idle 상태 감지와 같이 일반적으로 사용되는 이벤트 발생원을 포함해서, X Window System의 이벤트와 같이 외부의 이벤트 발생원으로부터 나오는 이벤트들을 일관적인 형태로 처리할 수 있습니다. 이것을 통해 GTK+ 가 이벤트 기반의 위젯 컨트롤이라던지, 각종 이벤트 / 시그널 처리를 할 수 있는 기반을 마련하게 됩니다. 예를 들어볼까요? 눈에 보이는 것을 들어보자면, 마우스를 움직여 스크롤 바를 내린다던지, 마우스 오른쪽 버튼을 팝업 메뉴를 띄우는 것도, X 로부터 발생하는 이벤트를 넘겨받아 프로그래머가 의도한 대로 처리하게 하는 것입니다. 이해를 돕기위해 눈에 보이는 것을 예로 들었지만, GLib에서는 눈에 보이건, 보이지 않건 상관없이 동일한 이벤트 loop을 사용해서 이벤트 기반의 프로그램을 만들 수 있습니다.\nGLib에 대해서 추가적으로 알고 싶으시다면, GLib API 매뉴얼을 참고하시길 권장합니다.\nGTK+ 객체 시스템(Object System) #  앞에서 언급했듯이, GTK+는 객체 지향 프로그램을 위한 특별한 지원이 없는 C로 작성되었지만, GTK+ 의 디자인은 객체 지향을 중심으로 이루어져있습니다. 소위 객체지향의 전통적인 기능들인 상속(Inheritance), 다형성(Polymorphism), 레퍼런스 카운팅(Reference counting) 은 물론이고, 위젯 툴킷에 적합한 기능- 즉, 알림(Notification)을 위한 시그널 처리 시스템을 포함해서, 객체 속성(Attribute) 시스템과 같은 것으로 구성되어있습니다. 이러한 기능을 바탕으로, GTK+ 객체 시스템이라는 하나의 계층(layer)로 자리잡고 있습니다.\nGTK+ 객체 시스템에 포함된 상속 기능은 서로간의 Nesting Structure (주: 구조체 내에서 구조체를 멤버 변수로 사용함)를 통해 만들어졌습니다. 예를 들어 설명해볼까요? GtkButton 클래스는 GtkWidget 클래스로부터 상속을 받습니다. 이렇게 될 경우, GtkButton 구조체의 첫번째 부분은, 바로 GtkWidget 구조체가 되는 것입니다. 이 말은 GtkButton을 가르키는 포인터가 GtkWidget을 가르키는 포인터로 타입 캐스팅될 수 있다는 것이 됩니다. 각각의 클래스는 \u0026ldquo;각자의 클래스 함수 구현을 가르키는 함수 포인터가 모인 테이블\u0026quot;을 포함하는 방식을 통해, 부모 클래스로부터 오버라이딩을 할 수 있게 합니다. (예를 들자면, GtkWidgetClall 구조체가 draw() 함수를 가르키는 포인터를 가지고 있게 되면, GtkButtonClass는 자신을 그리는 구현체(Implementation)만 제공하는 것으로 버튼을 그릴수 있다는 겁니다.)\n각 GTK+ 객체 클래스는 관련된 시그널의 집합체를 가지고 있습니다. 각각의 시그널은 특정한 형태의 이벤트나, 어플리케이션에서 호출(Callback)을 할 수 있는- 소위 \u0026ldquo;발생\u0026quot;의 의미를 가집니다. 예를 들어볼까요? GtkButton 클래스는 \u0026ldquo;clicked\u0026rdquo; 라는 시그널을 제공하는데, 이 시그널은 사용자가 그 버튼 위젯을 눌렀을 때 발생(주: 영문으로는 Emission, Emitted 라는 표현을 사용합니다)하게 됩니다. 하나의 시그널에는 여러개의 Callbacks가 연결될 수 있고, 시그널이 방출될 경우에는 연결되어 있던 모든 Callback을 향해 보내지게 되어, 이들을 순서대로 호출하게 될 것입니다. 시그널은 또한, 위젯의 행동을 변화시키는 데에도 사용될 수 있습니다. 예를 들자면, GtkEntry 위젯의 \u0026ldquo;insert_text\u0026rdquo; 시그널에 콜백 함수를 연결하게 될 경우, 숫자만 입력되게 한다던지, 또는 특정 문자만을 입력하게 한다던지 등의 필터링을 할 수 있는것 처럼 말이죠.\n각각의 클래스는 자신과 관련된 인자(arguments)의 집합을 가지고 있습니다. 각각의 인자는 그 위젯이 가진 몇몇 특성을 표현할 수 있습니다. 예를 들자면, GtkLabel 위젯은 \u0026ldquo;label\u0026rdquo; 이라는 인자를 제공하여, 그 위젯에 들어갈 임의의 텍스트를 설정하게 하거나, \u0026ldquo;justify\u0026rdquo; 인자를 제공하여 레이블의 자리맞춤을 하게 할 수도 있는것 처럼 말입니다. 이러한 인자 시스템은 실행 시간대(run-time)에 동적으로 적용될 수 있다는데 그 장점이 있습니다. 쉽게 말하자면, 앞으로 어떤일이 벌어지는지 알 필요 없이, 몇몇 인자를 설정하는 것으로 상황에 맞는 인터페이스를 제공할 수 있게 된다는 것입니다.\n KLDP에서, GTK+ Object System 에 관련된 토론기록을 보실 수 있습니다. comp.os.linux.advocacy 메일링 리스트에서 벌어진 GTK+ Object System 관련 토론기록을 보실 수 있습니다.  GDK #  GDK 라이브러리는 GTK+ 위젯(어플리케이션)과 윈도우 시스템을 이어주는 추상적 계층을 제공해줍니다. 다르게 말하자면, 무언가 화면에 그려줘야 할 것이 있다던지, 혹은 이벤트를 핸들링하고자 할 때 어플리케이션이 X 윈도우 시스템에 직접 호출을 하는 것이 아니라, GDK를 호출하여 처리하게 합니다.\n윈도우 시스템과 어플리케이션 사이의 추상적인 계층은 여러가지 이점을 가져옵니다. 첫번째, 이식성(Portability)를 높일 수 있습니다. GTK+ 를 X 윈도우 시스템이 아닌 다른 윈도우기반 시스템 (Win32, Mac OSX, DirectFB 등등)에 포팅하는데는 GDK 계층을 옮기는 것만으로 해결 할 수 있습니다. 게다가 GTK+ 프로그램이 존재할지 안할지 모르는 X 확장(extensions)에 투명성있게 접근할 수 있는 기반을 제공해줍니다. 마지막으로, GDK 호출은 X 호출에 비에 응답하기 간편합니다. 평소에 거의 사용되지 않는 파라미터 값을 주지 않아도, 다른 파라미터 값에 맞는 적절한 값을 자동적으로 결정해주기도 합니다.\nGDK API 레퍼런스 문서를 통해 GDK에 대한 더욱 상세한 내용을 보실 수 있습니다.\nDrag and Drop(DND) #  드래그 앤 드롭(Drag and Drop, aka DND)을 사용해서 정보를 옮기는 것은, 대부분의 현대적인 사용자 인터페이스에서 가능한 일입니다. 사용자가 마우스를 가지고 원본(source)을 클릭하여, 옮길 곳(destination)으로 끌고 갈(drag)수 있습니다. 아이콘은 사용자에게 행동에 대한 피드백을 위해 보여지는 것입니다. GTK+ 는 사용하기 쉽고, 프로그래머가 자신이 충분이 원하는 대로 바꿀 수 있는 드래그 앤 드롭 기능을 일련의 인터페이스를 통해 제공합니다. 이 인터페이스들을 사용하는 것으로 어플리케이션은 모티프(Motif, 주: POSIX - Compliant 시스템에서 동작하는 그래피컬 위젯 툴킷.)나 Xdnd 드래그 앤 드롭 프로토콜을 지원하는 프로그램들과 상호 연계될 수 있습니다.\nGTK+ 인터페이스는 원본(source)과 목표지점(destination) 관점이라는 2개의 부분으로 나뉘어져있습니다. 그 두개의 관점에서도 드래그 앤 드롭 행동의 세부적인 커스토마이징이 가능한 저수준(low-level) 인터페이스와, 일반적인 형태의 드래그 앤 드롭을 비교적 간단한 코드를 통해 구현하는 고수준(high-level) 인터페이스로 구분을 할 수 있습니다.\n내부적으로, GTK+는 전통적인 Motif 의 드래그 앤 드롭 프로토콜과, 새로운 Xdnd 드래그 앤 드롭 프로토콜을 지원합니다. 어플리케이션을 만드는 프로그래머의 입장에서는 특별한 노력없이, Xdnd 프로토콜(일례로, Qt와 Star Office가 Xdnd 프로토콜을 지원합니다)과 이미 많은 수를 차지하는 Motif 프로토콜을 사용하는 어플리케이션과 상호작용이 가능합니다. (다른말로 이야기 하자면, 투명성을 가지고 있다는 뜻입니다)\nXdnd 프로토콜은 전송되는 데이터의 타입을 MIME 타입으로 취급합니다. 이 관습은 그놈 프로젝트 전체에 적용되어 있습니다.\n Drag-and-Drop in GTK+ and GNOME. GTK+2.0문서지만, 드래그 앤 드롭 개관을 살펴 볼 수 있습니다. GTK+ API 레퍼런스 - Drag and Drop 페이지에서, 고수준 인터페이스의 상세를 알 수 있습니다. GDK API 레퍼런스 - Drag and Drop 페이지에서, 드래그 앤 드롭의 저수준 인터페이스 상세를 알 수 있습니다.  테마(Themes) #  GTK+는 테마를 통해 사용자 인터페이스의 사용자화를 지원합니다. GTK+나 어플리케이션을 재 컴파일 할 필요없이, 사용자는 단순히 새로운 테마를 설치하는 것 만으로도 어플리케이션의 새로운 모습을 선택할 수 있습니다. 테마는 단순히 색상의 집합뿐만 아니라, 현존하는 드로잉 코드에서 사용되는 그림(pixmap)만 추가/변경하거나, 위젯을 그리는 기능 자체를 완전히 바꿀 수 도 있습니다. GTK+ 에서 테마가 어떻게 동작하는지를 이해하기 위해서는 몇가지의 개념이 필요합니다. 첫째로, 스타일(style)은 각각의 위젯을 어떻게 그리느냐에 대한 정보의 집합을 의미합니다. 색상에 대한 정보, 배경에 들어갈 그림, 위젯에 들어갈 글꼴 등이 이들에 해당합니다. 스타일은 또한, 위젯의 기본 구성품을 어떻게 그리는지에 대한 코드가 들어있는 공유라이브러리인 \u0026ldquo;테마 엔진(theme engine)\u0026ldquo;을 가르키는 포인터를 포함합니다. (그림자 들어간 박스, 프레임, 화살표, 체크 버튼 표시부 등등이 위젯의 기본 구성품에 포함됩니다) 배포판마다 그 이름은 대개 다르지만, gtk-engines-* 라고 들어가는 패키지들이 이들 테마 엔진입니다.\n어플리케이션의 색상, 글꼴, 그리고 위젯을 위해 사용되는 테마 엔진등은 리소스 파일(resource file)로 설정됩니다. 리소스 파일에는 특정 테마 엔진에 관련된 데이터를 포함할 수도 있으며, 최종적으로 테마는 리소스 파일과 그림 파일과 같이 필요한 파일들의 조합으로 이루집니다.\n그놈(GNOME) 에서는 일관된 테마의 배포를 위해 표준 파일 형식을 정의하고 있습니다. 이들 기준을 간략하게 살펴보면, 테마파일은 테마의 이름으로 된 디렉토리가 들어있는 타르볼(주: .tar, .tar.gz 와 같이 tar로 묶여있는 파일)이어야 하며, 이 디렉토리의 내부에는 README.html 파일과, PNG 형식의 아이콘인 ICON.png 파일, 그리고 각각의 테마 정보가 들어있는 하위디렉토리가 존재해야 합니다. GTK+ 테마 정보는 반드시 gtk 라는 이름의 하위디렉토리에, 리소스 파일은 gtkrc 라는 이름으로 들어가 있어야 합니다.\n GTK+ 리소스 파일 레퍼런스 : Resource Files 페이지에서 리소스 파일에 대한 레퍼런스를 보실 수 있습니다. GTK+ CSS : CSS를 이용해서 GTK+에 스타일을 적용할 수 있습니다. Themeable Stock Images : Themeable Stock Icons 페이지에서 스톡 아이콘에 대한 레퍼런스 매뉴얼을 보실 수 있습니다.  참고로, 이 문서는 그놈 홈페이지의 Architecture Overview를 바탕으로 작성되었으며, 예전 페이지 를 현재 상황에 맞게 고친 것입니다.\n"});index.add({'id':6,'href':'/docs/develop/begin/','title':"Begin",'section':"Develop",'content':"처음 시작하시는분을 위한 가이드 #  이 페이지에서는, 그놈(GNOME) 데스크탑 환경을 기반으로 하는 소프트웨어의 개발이나, 그놈(GNOME)을 더욱 풍성하게 만들어주는 공헌을 해주실 분을 위한 기초적인 가이드라인을 제시합니다.\n그놈(GNOME) 프로그램 개발 개요 페이지를 통해, 그놈(GNOME) 데스크탑 환경을 구성하는 핵심 기술과, 내부 통신 방법, 데스크탑 편의성을 위한 기술등에 대해 학습하실 수 있습니다.\n그놈(GNOME) 데스크탑 환경에 공헌할 수 있는 방법들에 대한 요약 #  프로그래밍에 대한 지식이 필요없이, 아래와 같이 그놈(GNOME) 데스크탑 환경의 발전에 도움을 주실 수 있습니다:\n여러분이 사용하시는 그놈(GNOME) 플랫폼의 소프트웨어에 대한 문제를 발견하거나, 좀 더 나은 방향으로의 변화를 위하여 그놈 버그 트래커를 통해 버그를 보고할 수 있습니다. 버그 보고에 대한 자세한 사항을 버그 보고 방법(영문) 문서를 통해 알 수 있습니다.\n그놈(GNOME) 플랫폼에서 동작하는 소프트웨어들의 메뉴나, 대화창에 적혀있는 메시지나, 프로그램 사용에 도움을 주는 문서들을 작성하거나, 번역하는 것으로도 도움을 줄 수 있습니다. 어렵게 생각하지 마세요! 그놈 한국 irc 채널에 오시면 그것에 관련된 대화를 접하시고, 도움을 주시는데 보다 손쉬운 방법을 알 수 있습니다.\n프로그래밍에 대한 지식이 있으시다면, 다음과 같은 방법으로 도움을 주실 수 있습니다:\n현재 그놈(GNOME) 프로젝트의 진행 상태는 여기에서 보실 수 있습니다. 언급한 페이지에는 현재 진행중이거나, 또는 개선해야 할 사항 (TODO)과 함께 그놈 프로젝트의 여러가지 컴포넌트의 개발에 관련된 연락처 등을 다루고 있습니다. 이곳을 통해, 지금 어디에, 어떤 것을 도울 수 있는지 손쉽게 알 수 있습니다.\n그 밖에도, 여러가지 컴포넌트들에 대한 테스트, 또는 버그 보고등을 통해서도 도움을 줄 수 있습니다. 최신의 그놈(GNOME) 프로젝트의 컴포넌트들을 GNOME gitlab를 통해 접근할 수 있습니다.\n그놈 개발 환경의 발전을 위해, 그놈 문서화 프로젝트에도 참여하실 수 있습니다.\n그놈 개발자 플랫폼 라이브러리(API) 문서에 대하여 #  API 문서를 보기 위해, 첫째로 DevHelp를 사용하는 방법이 있습니다. 이 프로그램을 사용하여, 자신이 사용하는 현재 버전의 라이브러리에 대한 문서를 읽고, 검색할 수 있습니다. 또한, API 참고서 웹 페이지를 통해 그놈(GNOME) 플랫폼 기반의 프로그램을 작성하는데 도움을 줄 수 있는 최신 API 문서를 만나실 수 있습니다.\n기타 도움을 받을 수 있는 문서에 대하여 #  라이브러리 API에 대한 문서이외에도, 그놈 개발 안내서 와 초보자 지침서 및 예제 코드를 통해 좀 더 손쉽게 그놈(GNOME) 프로그래밍을 배울 수 있습니다.\n알림: 이 글은 원본 글을 수정한 것입니다.\n"});index.add({'id':7,'href':'/docs/develop/i18n/','title':"I18n",'section':"Develop",'content':"오래된 문서입니다. 업데이트 예정입니다.\nGettext를 사용한 I18N 학습서 #  이 페이지에서는 GNU/Gettext 를 사용하여 Gtk+ 기반의 프로그램을 국제화시키는 방법에 대하여 언급하고자 한다.\nGNU gettext의 라이센스에 대하여 #  GNU Gettext의 라이센스는 GPL이다, 허나 GPL은 Gettext PO파일을 다루는 프로그램에 적용되고, 프로그래밍에 사용되는 libintl 은 LGPL로 관리되고 있다. 인터페이스인 libintl.h 는 glibc에 적용되어 있기때문에, 이들 코드를 상용 소프트웨어를 만드는데 사용해도 상관이 없다고 할 수 있다.\nI18n, l10n 에 대하여 #  이 부분에 대해 더욱 자세한 사항을 알고 싶으면 다음의 페이지를 참고하길 바란다:\nhttp://www.gnu.org/software/gettext/manual/html_mono/gettext.html 소프트웨어에 대한 국제화를 이야기 할때 항상 빠지지 않는 두 단어가 있다. 바로 Internationalization과 Localization 인데, 많은 이들이 이들 긴 단어를 치는데 지친 나머지 I18n과 l10n이라고 쓰게 되었다. 이들 두 단어에 대한 정확한 정의는 다음과 같다: Internationalization : 번역하기를 \u0026ldquo;국제화\u0026rdquo; 라고 한다. 이 단어는 패키지화 된 프로그램이 있을때 그 프로그램이 다양한 언어를 지원하도록 만들어진 것을 의미한다. 이는 다시말해 영어로 된 문자열을 사용하여 이루어지는 행동과, 영어 이외의 다른 언어로 이루어지는 행동이 \u0026ldquo;차이 없는\u0026rdquo; 일반화 과정(Generalization process)이라고 할 수 있다. 프로그램 개발자는 자신의 프로그램에 국제화를 적용할때 다양한 기술을 사용할 수 있는데, GNU gettext는 이들 표준중에 하나를 제공하는 것이라고 할 수 있다.\nLocalization : 번역하기를 \u0026ldquo;지역화\u0026rdquo; 라고 한다. 지역화는 국제화(I18n)가 모집합인 집합 구성원으로 (쉽게 말해 이미 국제화가 된 소프트웨어만 국제화를 진행 할 수 있다는 뜻이다), 관련된 정보를 특정 지역의 언어/문화에 관련된 행동양식에 맞추어 (예를 들자면 화폐단위, 지역시간 등) 사용할 수 있게 하는 것이라고 할 수 있다. 이는 특정방법으로 이미 국제화로 일반화된(Generalized) 프로그램을 부분화시키는 작업이라고도 할 수 있다. 이들 지역화의 구분은 특별한 환경 변수를 바탕으로 프로그램 실행전에 \u0026ldquo;어느 로케일에서 사용되고 있는지\u0026quot;를 파악, 실행시간대에 그것을 적용하게 하는 것이다.\n프로그래머의 접근 방법 #  준비단계 #  가장 처음 프로그래머가 자신의 프로그램에 gettext를 적용하기 위해서 할 일은, C 코드에 gettext를 적용할 수 있도록 준비하는 것이다. 이 과정에는, gettext를 설치하고, 자신의 코드에 libintl.h 를 include 하는 일과, 갖가지 매크로를 정의하는 일도 포함되어 있다. 그리고 가장 중요한 것은, 번역할 문자열과 아닌 문자열을 구분 할 수 있게 매크로에 맞게 수정하는 일이 될 것이다.\n코드 적용 #  자신의 코드를 그것에 맞게 수정을 하게 되면, 그때 부터 gettext의 각종 툴과 설정으로 적용을 시켜나가야 할 것이다. 이 과정은 예제 C 코드를 들어 설명하고자 한다:\n /* 샘플 코드: gettext_sample.c */ #include \u0026lt;libintl.h\u0026gt; #include \u0026lt;locale.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; /* 매크로를 잡아준다. gettext를 매번 쳐서 넣어주기는 귀찮으니까. 이렇게 될 경우에는, xgettext를 사용시 옵션을 줘서 어떤 매크로가 사용되었는지 키워드를 알려줘야 한다 */ #define _(String) gettext (String) /* 원래 PACKAGE와 LOCALEDIR은 autoconf/automake 사용시에 config.h 로 생성되어야 * 할 부분이다. 현재 값으로 들어가게 되면 각 로케일에 맞는 번역 MO파일을 * 현재디렉토리/locales/자신의로케일/PACKAGE 상수에 들어간 값.mo 로 찾게 된다. * 자세한 것은 뒤의 장에서 추가로 설명할 것이다 */ #define PACKAGE \u0026quot;gettext_sample\u0026quot; #define LOCALEDIR \u0026quot;locales\u0026quot; int main (void) { // 밑의 3줄은 gettext를 사용함에 있어 가장 기초적인 베이스 코드이다. setlocale (LC_ALL, \u0026quot;\u0026quot;); bindtextdomain (PACKAGE, LOCALEDIR); textdomain (PACKAGE); printf (_(\u0026quot;This is gettext sample program.\\n\u0026quot;)); printf (\u0026quot;original message: %s\\n\u0026quot;, \u0026quot;World\u0026quot;); printf (\u0026quot;gettext trans: %s\\n\u0026quot;, _(\u0026quot;World\u0026quot;)); return 0; } PO 파일 추출 #  이제 xgettext 를 사용하여 번역할 부분만 추출된 PO 파일을 생성해야 한다. 기본적으로 위의 코드를 저장하고 다음과 같이 실행해보도록 한다:\n$ xgettext -C gettext_sample.c -o gettext_sample.po -C 옵션은 이 파일이 C 언어로 된 파일이라는 것을 명시해주는 것이다. -o filename 옵션은 출력파일의 이름을 정하는 것이다. 기본적으로 messages.po 로 만들어진다. 자, ls로 파일이 만들어진지 확인해보도록 하자. 없다! 이 사항은 gettext() 로 번역해야 할 사항들을 검색하기 때문에, 아무것도 찾지 못하기 때문에 출력물이 나오지를 않는것이다. 이 부분은 키워드를 지정해서 해결하도록 한다. 다시 다음과 같이 실행해보자:\n$ xgettext -k_ -C gettext_sample.c -o gettext_sample.po 키워드의 지정은 -k_ 거나 \u0026ndash;keyword=_ 둘중 아무거나 선택해도 된다. 자세한것은 man페이지를 참조.\nPO 파일의 수정 #  자, 이제 gettext_sample.po 파일을 얻었다. 이제 남은 것은 emacs나 vi로 po 파일을 직접 수정하거나 (그중에서 emacs의 po-mode 를 사용하면 편리할 것이다), poedit 를 받아서 설치(wxWindows 가 필요하다. 리눅스에서는 wxGTK.) 하여 사용하는 방법이 있다. 이래저래 파일을 들여다보는 것도 좋지만, 목적달성을 위해서 최대한 잡일을 줄인다는 목표로 poedit를 사용하기를 권장한다.\nPO 파일을 수정할 때 주의할 사항은, 인코딩과 국가 설정, 그리고 초기 설정을 전부 갱신해야 한다는데 있다. poedit를 사용하면 이들 부분을 전부 체크해줄 뿐만 아니라 mo 파일까지 생성해준다. (물론 옵션이다) 편한 세상에서 살고 있는 것이다.\n그래서 만들어진 PO 파일을 보도록 하자.\n # gettext_sample.c 의 PO 파일: gettext_sample.po # Copyright (C) 2006 by luna_j'etch # This file is distributed under the same license as the gettext_sample # package. # luna_j'etch \u0026lt;luna.jetch@test.org\u0026gt;, 2006. # msgid \u0026quot;\u0026quot; msgstr \u0026quot;\u0026quot; \u0026quot;Project-Id-Version: gettext_sample\\n\u0026quot; \u0026quot;Report-Msgid-Bugs-To: \\n\u0026quot; \u0026quot;POT-Creation-Date: 2006-06-26 22:04+0900\\n\u0026quot; \u0026quot;PO-Revision-Date: 2006-06-26 22:21+0900\\n\u0026quot; \u0026quot;Last-Translator: LunA J`etch \u0026lt;luna.jetch@test.org\u0026gt;\\n\u0026quot; \u0026quot;Language-Team: KO LANG Team \u0026lt;ko@test.org\u0026gt;\\n\u0026quot; \u0026quot;MIME-Version: 1.0\\n\u0026quot; \u0026quot;Content-Type: text/plain; charset=utf-8\\n\u0026quot; \u0026quot;Content-Transfer-Encoding: 8bit\\n\u0026quot; \u0026quot;X-Poedit-Language: Korean\\n\u0026quot; \u0026quot;X-Poedit-Country: KOREA, REPUBLIC OF\\n\u0026quot; \u0026quot;X-Poedit-SourceCharset: utf-8\\n\u0026quot; #: gettext_sample.c:16 #, c-format msgid \u0026quot;This is gettext sample program.\\n\u0026quot; msgstr \u0026quot;이것은 gettext 샘플 프로그램입니다.\\n\u0026quot; #: gettext_sample.c:19 msgid \u0026quot;World\u0026quot; msgstr \u0026quot;세계\u0026quot; PO에서 MO로 변환 #  po 파일을 mo 파일로 생성하는 과정은 다음과 같다: (사실 이과정은 poedit를 사용하면 필요가 없다)\n$ msgfmt gettext_sample.po -o gettext_sample.mo -v 번역된 메시지 2개.\nverbose 모드로 결과를 보면, 메시지 2개가 번역되었다고 한다. 앞으로 사용하다보면 fuzzy 번역문이 나올 수도 있는데, fuzzy는 번역으로 인정하지 않으므로 다른 프로젝트에 봉사할 때에는 fuzzy 번역문이 없도록 해 주자.\n실행을 위한 적용 #  이렇게 만들어진 mo 파일을 실행파일에 적용하기 위해서는 그 경로의 설정 또한 중요하다. 앞의 샘플 소스에서 언급했지만, 이 부분은 gettext가 적용되기 위해서 찾아가는 모든 경로에 대한 염두를 해 둬야 한다. strace(1) 을 사용하여 gettext 구동에 필요한 입출력이 어떻게 이루어지는지 확인하여 눈으로 익혀두는 방법을 권장한다.\n위 샘플 코드를 기준으로, gettext가 적용되면 다음과 같은 입출력을 하게 된다:\n\u0026ldquo;/usr/lib/locale/locale-archive\u0026rdquo; 를 검색한다 \u0026ldquo;/usr/share/locale/locale.alias\u0026rdquo; 즉, 로케일 명 alias 데이터베이스를 검색한다. 여기서 자신의 로케일명과 맞아 떨어지는 부분이 있으면 그 디렉토리를 검색하게 될 것이다. \u0026ldquo;/usr/lib/locale/현재 LOCALE 환경 변수 명(+소문자:lower alphanumeric)/LC_*/PACKAGE상수값\u0026rdquo; 를 검색한다 그러다 없으면 \u0026ldquo;현재 작업 디렉토리/LOCALEDIR에 지정한 값(locales)/현재 로케일/LC_MESSAGES/PACKAGE상수값\u0026rdquo; 으로 찾는다 없으면 무시하고 그냥 소스에 적혀있는대로 출력하게 되고, 파일을 찾으면 번역을 해서 출력하게 된다.\nlibglade와 gettext, 그리고 intltool #  커맨드 라인에서 동작하는 프로그램의 경우야 그렇다 치더라도, 이제 GUI 기반의 프로그램 (특히, 여기서 언급하고자 하는 것은 Gtk+-2.x 를 기준으로 한다) 에 대한 적용단계가 있다. 그 중에서, glade, a User Interface builder (이하 glade) 를 사용해 만든 프로그램에서 어떻게 적용하는지에 대해 언급하고자 한다.\nglade로 UI를 구성 한 후 Code generation을 했을 경우라면 옵션에서 -\u0026gt; C 옵션 중 gettext 지원에 체크만 해 놓더라도 UI에 대한 메시지는 gettext를 지원할 수 있게 되어 있다.\nglade xml로 저장하고, libglade를 사용하여 동적으로 UI를 생성하는 것이라면 이야기가 약간 달라진다. 이때는 xml 파일에서 gettext를 쓸 수 있도록 무언가를 생성해야 하는데, 이때 사용하는 것이 바로 intltool 이다.\nglade-xml 로부터 메시지 추출 #  그 중 만들어진 glade-xml 파일에서 gettext 지원을 할 수 있도록 도와주는 툴은 intltool-extract 이다. 말 그대로 xml 파일로 부터 C header 파일을 \u0026ldquo;추출\u0026quot;하기 위한 유틸이다. 사용법은 man 페이지를 참조하고, 다음의 커맨드를 살펴보자: (예제는 언젠가 만들어놓은 PDFLib-Dompdf HTML to PDF Renderer 의 것이다)\n $ intltool-extract --type=gettext/glade psp_main.glade Generating C format header file for translation. Wrote psp_main.glade.h 추출을 하기 전, 해당 xml 파일을 전부 영문으로 바꿔놓아야 한다.\n타입에는 glade-xml 파일 이외에 gettext/ini, gettext/scheme 등이 가능하므로 man 페이지를 자세히 들여다 보길 바란다. 실행이 완료되면 psp_main.glade.h 파일이 생성되는데, 그 파일의 속내를 들여다보자:\n char *s = N_(\u0026quot;DomPDF HTML Shoveling Previewer 0.3Beta1 Release\u0026quot;); char *s = N_(\u0026quot;Landscape\u0026quot;); char *s = N_(\u0026quot;Next Page\u0026quot;); char *s = N_(\u0026quot;Open File...\u0026quot;); char *s = N_(\u0026quot;Previous Page\u0026quot;); char *s = N_(\u0026quot;Print\u0026quot;); char *s = N_(\u0026quot;Print(_T)\u0026quot;); char *s = N_(\u0026quot;Refresh\u0026quot;); char *s = N_(\u0026quot;Refresh(_F)\u0026quot;); char *s = N_(\u0026quot;Scale\u0026quot;); char *s = N_(\u0026quot;_About\u0026quot;); char *s = N_(\u0026quot;_File\u0026quot;); char *s = N_(\u0026quot;_Help\u0026quot;); char *s = N_(\u0026quot;_View\u0026quot;); 위와 같이 glade-xml 에 들어있던 레이블이 모두 모여서 N_() 으로 감싸져있다. 이는 배열 내의 값을 gettext로 변환하는 gettext_noop() 의 매크로 축약인데, UI에서 사용되는 다른 부분이 전부 배열로 선언되어 사용되기 때문이다. 사실 이 부분은 xgettext 에서 사용될 \u0026ldquo;가짜 C 파일\u0026rdquo; 이므로, xgettext를 사용하여 문자열을 뽑아낼때 추가시켜 주면 된다. 실제 컴파일에 영향을 미치지는 않으므로, 키워드에 N_ 을 추가시켜서 xgettext를 실행시켜야 할 뿐, 다른 것은 없다. 밑에 PO 파일 생성 부에서 다시 이 파일을 언급하고자 한다.\n메인 프로그램의 수정 #  만약 define된 스트링 상수가 있다면 (예를 들자면 about 에 들어갈 내용이라던지) 그 부분에 _() 매크로를 덧씌워 주도록 한다.\n#define PSPV_PROGRAM_NAME _(\u0026ldquo;DomPDF HTML Rendering Previewer\u0026rdquo;) #define PSPV_VERSION _(\u0026ldquo;0.3beta1\u0026rdquo;) #define PSPV_LICENSE _(\u0026ldquo;Licensed Under GNU Public License V2 or more.\u0026quot;) #define PSPV_COMMENTS _(\u0026ldquo;Simple DomPDF HTML Renderer helper tool\u0026rdquo;) #define PSPV_COPYRIGHT _(\u0026ldquo;2006 (C) LunA_J`etch\u0026rdquo;)\n이 부분이 완료 되면, 이제 앞에서 보았던 샘플 코드 처럼 베이스 코드를 추가하도록 하자. 구현에 대한 상세는 Gettext 사용법을 익히기위해 필요하지 않으므로, 생략한다.\n // ...(전략)... #include \u0026lt;libintl.h\u0026gt; #include \u0026lt;locale.h\u0026gt; /* gettext 매크로 정의 */ #define _(String) gettext (String) #define N_(String) gettext_noop (String) #define PACKAGE \u0026quot;pspv\u0026quot; #define LOCALEDIR \u0026quot;locales\u0026quot; // ...(중략)... int main (int argc, char *argv[]) { /* gettext 적용을 위한 코드 */ setlocale (LC_ALL, \u0026quot;\u0026quot;); bindtextdomain (PACKAGE, LOCALEDIR); textdomain (PACKAGE); g_thread_init (NULL); gdk_threads_init (); gtk_set_locale (); gtk_init (\u0026amp;argc, \u0026amp;argv); gp_xml_main = glade_xml_new(GLADE_LAYOUT_PATH, NULL, NULL); glade_xml_signal_autoconnect(gp_xml_main); /* layout initialization */ init_layout (); init_accelerator (); // ... (후략) ... PO 파일 생성, 그리고 결과 #  베이스 코드가 추가되었다면, 이제 po 파일을 뽑아내보도록 하자.\n앞에서 glade xml로 부터 만들어진 가짜 C 코드(psp_main.glade.h)를 활용하여, po 파일을 뽑아야 한다. 다음의 커맨드를 사용하자:\n$ xgettext -kN_ -k_ -C pspv.c pspv.h psp_main.glade.h -o pspv.po 위 3개의 헤더 파일 및 C 파일에서 원하는 스트링을 찾아내서 po 파일을 만들어 줄 것이다. 이제 poedit를 사용해서(혹은 emacs의 po-mode를 쓰던지) mo 파일을 생성하도록 하자. 생성된 mo 파일을, 적절한 위치에 가져다 주자. 위치에 대한 설명은 3장을 다시 살펴보자.\n모든 것이 끝나면, 이제 프로그램을 재 컴파일 하고 실행한다. 그럼 짜잔~ 하고 한글로 번역된 프로그램이 보일 것이다.\n아래는 적용된 결과물 예제:\n기타 주요 사항 #  printf() 와 출력순서에 대하여 #  메시지 번역을 하다보면, 영문과 한글의 어순이 달라서 출력의 순서까지 변경해야 하는 경우가 생긴다. (그렇지 않으면 \u0026ldquo;luna 그룹에 audio 유저 추가(주: gpasswd의 번역오류이다)\u0026rdquo; 와 같은 문제가 발생한다. 이 문제는 printf()에서 지원하는 서식 문자열 기능을 써서 출력 순서를 정해주는 것으로 해결 할 수 있다.\n예를 들어 보자: \u0026ldquo;%d of %d\u0026rdquo; -\u0026gt; \u0026ndash;\u0026quot;%d 중 %d 개\u0026rdquo;\u0026mdash; 가 아닌 \u0026ldquo;%2$d 중 %1$d 개\u0026rdquo; 로 표기하여 해결 할 수 있는 것이다.\n배열에 gettext 를 적용하려면 gettext_noop() 을 사용한다 #  배열에 gettext 번역을 적용하고 싶을 때는, gettext_noop()을 사용한다. 어차피 gettext_noop은 xgettext 프로그램을 위한 코드이므로, C 컴파일러에서 안전하게 처리 될 수 있도록 미리 매크로 축약을 구성하도록 한다.\n /* gettext_noop()을 배열에 적용할때 컴파일러에서 안전하게 처리되도록 하기 위한 매크로와, * 그것의 매크로 축약을 정의해둔다 */ #define N_(String) gettext_noop(String) #define gettext_noop(String) (String) static const char *err_messages[] = { N_(\u0026quot;Errno 1: File not found\u0026quot;), N_(\u0026quot;Errno 2: Cannot execute execl(), bugs?\u0026quot;) }; 그리고 xgettext를 사용할때는 -kN_ 으로 키워드를 추가해놓는 것이 좋다. :)\n출처: https://web.archive.org/web/20070528043820/http://www.gnome.or.kr/c/portal/layout?p_l_id=PUB.1.88\n"});index.add({'id':8,'href':'/docs/develop/tools/','title':"Tools",'section':"Develop",'content':"작성 중입니다.\n"});index.add({'id':9,'href':'/docs/gnome_history/gimp_gtk/','title':"Index",'section':"Docs",'content':"그놈 프로젝트는 김프라는 그림 편집 및 그리기 도구 개발에서 시작한다. 아래 만화를 통해 김프 프로젝트의 시작과 김프에서 어떻게 Gtk+ 프로젝트가 시작되었는지 확인할 수 있다.\n김프(GIMP)의 탄생 #  1995년 스펜서 킴벨(Spencer Kimball)과 피터 매티스(Peter Mattis)는 UC 버클리에서 전산학을 공부하고 있었다.\n“LISP 컴파일러 과제 시작했어?”\n“컴파일러 보다 다른 것을 만들어보고 싶어.”\n“나도, 대신에 리눅스용 포토샵 같은거 만들어보면 어떨까? 포토샵은 맥하고 윈도에서만 실행되잖아.”\n“좋은 생각이다. 우리 교수님한테 한번 이야기해보자.”\n“저희가 LISP 컴파일러 프로젝트 대신에 포토샵 같은 이미지 편집 프로그램을 한번 만들어보고 싶습니다.”\n“교수님도 유닉스 쓰고 있잖아요? 그런데, 포토샵 같은 이미지 편집 프로그램이 없어요. 저희가 한번 만들어보고 싶습니다.”\n“음.. 좋은 생각이네. 대신 윈도용 그림판 수준으로 만들면 C 밖에 못줘.”\n“포토샵에 보면 클릭만 하면 자동으로 비슷한 색깔 영역이 선택되잖아? 그거 신기한데, 그걸 구현하면 내가 A+를 주지.”\n“아, 네 물론이죠.”\n“그 기능이 뭔지 알어?”\n“뭔데?”\n“포토샵을 그냥 구현하라는 말씀이야.”\n두 사람은 이미지 편집 프로그램 이름을 김프 GIMP(General Image Manipulation Program)라고 짓고, 거의 10개월 정도 개발에 몰두한다.\n“이제 김프를 공개해도 될 것 같아.” “플러그인도 지원하고, 교수님이 이야기한 자동 영역 선택 기능도 있고, 그림 그리기 도구에에 채널까지.” “게다가 포토샵에 없는 다단계undo/redo 기능까지.”\n1996년 김프 0.54가 소스코드와 함께 공개되었고, 리눅스, SGI-IRIX, HP 유닉스를 지원했다. 주요 기능은 다음과 같다.\n 8, 15, 16, 24 비트 컬러 지원 8 비트 디스플레이를 위한 디더링(dithering) 지원 RGB, 흑백, 인덱스 컬러로 그림 보기 지원 동시 여러 이미지 파일 편집 가능 실시간 줌(zoom)과 스크롤 지원. GIF, JPEG, PNG, TIFF, XPM 이미지 포맷 지원 사각형, 타원형, 자유, 퍼지(fuzzy), 베지어(bezier), 자동 선택 도구를 이용한 영역 선택 지원 회전, scale, shear and flip images. bucket, brush and airbrush painting tools 이미지 복사, convolve, 블렌딩 지원 텍스트 툴, 필터 효과(blur와 edge detect), 지원 채널과 컬러 조작 지원(add, composite, decompose). 플러그-인 시스템 지원 (새로운 파일 포맷 및 새로운 필터 추가 가능). 다단계 undo와 redo 지원 김프가 공개되지 마자, 수 많은 사용자들이 생겨났다.  “리눅스에서 이미지를 편집할 수 있다니… 감동”\n“와, 기능이 거의 포토샵 수준이라니까…”\n“사람들이 플러그인도 많이 만들어서 이미지 필터 효과도 아주 많네.”\n당시 김프 사용자였던 자흐 빈(Zach Beane)는 자신의 홈페이지에 사용자 튜토리얼을 만들어 공유했다.\n다른 사용자들도 김프로 만든 작품과 자신만의 테크닉을 공유했고. 이를 통해 더 많은 사람들이 김프를 사용하기 시작했다.\n“내가 김프 튜토리얼을 만들어봐야겠다.”\n당시 튜토리얼 페이지 일부(출처: archive.org)\n리눅스 마스코트 펭귄 턱스 레리 이윙(Larry Ewing)은 김프 0.54 버전을 이용해서 리눅스 마스코트인 펭귄 턱스(tux)를 그렸다.\n“리눅스 로고 컨텐스트가 있네. 주제는 펭귄! 리눅스가 자유 소프트웨어이니까, 김프로 한번 펭귄을 그려보자.”\n레리가 작업하던 김프 화면(출처: 레리 홈페이지)\n사람들의 투표로 레리가 그린 펭귄이 선정되었지만, 로고 대신 리눅스 마스코트로 현재까지 사용되고 있다. 당시에 이 그림이 김프로 그려진 사실 때문에 김프가 많은 조명을 받았다.\nGTK 위젯 #  하지만, 사용자들이 플러그인을 추가하면서 김프가 불안해지는 현상이 나타났다.\n“큰일이네. 플러그인 떄문에 자꾸 김프가 죽는다고 하네.”\n“모티프(motif) 때문에 플러그인 기능이 불안정한 것 같아.”\n“김프가 상용 위젯인 모티프에 의존성이 있는 것도 문제야.”\n“내가 위젯을 만들어볼까? 그래야 사람들이 리눅스에서도 쉽게 사용할 수 있지.”\n“어떻게?”\n“위젯과 윈도우 시스템이 연동하는 부분은 분리하는거야. 그래야 나중에 다른 플랫폼에 쉽게 포팅할 수 있지.”\n나중에 위젯은 GTK(GIMP toolkit)로, 윈도 시스템과 연동하는 포팅 레이어는 GDK(GIMP drawing kit)로 부르게 된다. 이때 부터 피터는 주로 위젯을 개발하고 스펜서는 김프 자체에 주력한다.\n“나 HP로 부터 오퍼 받았어.” “축하해.. 당분간 밤낮없이 일해야겠는데? 툴킷도 완성시켜야하고.”\nGPL 적용 #  “오~ 기특한 두 젊은이기 포토샵 대체 프로그램을 만들었다니, 이름도 김프(GIMP). G가 General이긴하지만… 메일을 하나 보내야겠다.”\n“대단한 이미지 편집 도구를 만드셨네요? 혹시 GPL 라이선스로 공개할 생각은 없나요?\n“네, 현재 모티프 의존성을 없애는 작업을 하고 있습니다. 그러면 GPL로 코드를 공개할 수 있을 것 같습니다?”\n“오.. 대단합니다. 혹시 이름에서 G를 GNU로 바꿀 생각은 없는지요?”\n“네, 물론이죠. 저희도 이맥스 에디터를 잘 쓰고 있고 GCC, 리눅스와 같은 자유 소프트웨어 덕에 이렇게 김프도 만들었는데…”\n“정말 생각이 바른 젊은이들야. 이로써, 포토샵을 대신할 새로운 자유 소프트웨어 확보!” “이제 부터 GNU Image Manipulation Program로 불러주세요~”\n1997년 6월 김프 0.60이 릴리즈 되었다. 더 이상 모티프 툴킷에 대한 의존성이 없었고 처음으로 GPL 라이선스가 적용되었다.\n“모티프 의존성이 없으니, 개발도 쉽고 배포도 자유로워졌네.”\n“그런데, 사람들이 이제 윈도 버전을 만들어달라고 하네”\n“기술적으로 GDK 윈도 백엔드를 구현하면 되는데, 난 이제 취직도 했으니, 누군가 구현하지 않을까? 오픈소스니까..”\n1998년 토어 릴크비스트(Tor Lilqvist)가 드디어 김프를 윈도용으로 포팅하기 시작한다.\n“김프 만든 사람들 천재군. 어떻게 위젯을 따로 다 만들었지? 게다가 포팅하기 쉽게 GDK로 포팅 레이어를 분리해놨어. 윈도용 포트 작업이 수월하겠는데..”\n1997년 2월 26일 두 사람은 김프 0.99 버전을 릴리스 한다. 이때 부터 GTK에 객체지향(OOP) 개념을 추가해서 GTK+라고 부르기 시작했다. 1997년 6월 9일 0.99.10을 마지막으로 두 사람 모두 취직을 하면서 더 이상 개발을 진행하지 못하게된다.\n“김프 새 버전은 안나오는거야?”\n“두 사람이 모두 직장을 잡아서 새롭게 릴리즈할 시간이 없는 것 같아.”\n“누군가 대신에 버그도 잡고 릴리즈도 하면 좋은데…”\n페데리코(Federico Mena Quintero)는 여러 버그 픽스를 모아서 간헐적으로 릴리즈를 진행했다. 하지만 새로운 기능이 추가되지는 않았다.\n“두 사람이 바쁜 것 같으니까, 나라도 메일링 리스트에 올라온 버그 패치를 적용해서 김프를 릴리즈해야겠다”\n1997년 2월 김프 공동체의 원활한 소통을 위해 IRC채널이 만들어졌고, 자연스럽게 몇몇 사람이 나서서 프로젝트를 계속 진행시켰다.\n마니시(Manish Singh, yosh)는 릴리스를 맡았고, 안드리안(Adrian Likins)은 서버를 관리하고 김프 캐릭터를 그렸던 래리(Larry Ewing, lewing)와 메튜(Matthew Wilson, msw)외 사람들이 버그를 잡고 새로운 기능을 구현했다.\n“내가 김프의 릴리즈를 맡을께요”\n“내가 서버를 관리하지요”\n“버그는 나에게 맡기고”\n“내가 새로운 기능을 구현하지”\n1998년 6월 2일 마침내 김프 1.0이 정식으로 출시되었고, 이 때 부터 GTK+는 별도의 프로젝트로 독립을 한다. 오늘날의 김프 #  김프 2.0 (출처: 위키피디아)\n현재 김프는 리눅스, 맥OSX, 윈도, BSD, 솔라리스를 지원하며 대표적인 오픈소스 그래픽 소프트웨어로 자리잡았다.\n그놈(GNOME) 프로젝트 #  일부 김프 개발자가 독자적인 프로젝트로 GTK+를 분리시켰고 이를 기반으로 또다른 오픈소스 데스크탑 프로젝트인 그놈(GNOME) 프로젝트가 탄생하게 된다. 이에 대한 이야기는 다음에 소개할 예정이다.\n두 사람은 이후 구글에서 함께 일하면서 구글 파일시스템, 서블릿 엔진 등 개발에 참여했고 Viewfinder라는 스타업을 만들어 스퀘어에 매각했다. 현재는 함께 새로운 스타트업에서 구글 빅테이블의 오픈소스 버전인 CockroachDB를 만들고 있다.\n참고 #   A Brief (and Ancient) History of GIMP, gimp.org 김프, 위키피디아 (한국어, 영문) 인터뷰 기사, 1997년 1월, https://www.xach.com/gg/1997/1/profile/1/ 김프 튜토리얼(링크)  "});index.add({'id':10,'href':'/docs/gnome_history/gnome_kr_home/','title':"Index",'section':"Docs",'content':"그놈 한국 홈페이지 변천사 #  2007년 2월 20일 #  https://web.archive.org/web/20070220235717/http://gnome.or.kr/\n2006년 7월 11일 #  2003년 10월 30일 #  2002년 3월 30일 #  https://web.archive.org/web/20020524140742/http://gnome.or.kr/\n"});index.add({'id':11,'href':'/docs/gnome_history/korea/','title':"Index",'section':"Docs",'content':"그놈 한국이 걸어온 길 #  작성 중\u0026hellip;\n"});index.add({'id':13,'href':'/docs/projects/gnome-kr-l10n/','title':"Gnome Kr L10n",'section':"Projects",'content':"그놈 한글화 프로젝트 #  그놈 한글화 프로젝트는 그놈 프로젝트에서 개발하는 애플리케이션을 한글화하는 프로젝트입니다. 여러분이 그놈을 기반으로한 우분투 리눅스를 설치할 때, 한글을 선택하면 모든 메뉴가 한글로 나타나는데, 이 프로젝트의 결과물입니다. 현재 프로젝트 멤버는 다음 같습니다.\n 감독자: 류창우(Changwoo Ryu) 검토자: 조성호(Seong-ho Cho) 번역  맹진영(Jinyeong Maeng) AlexKodala 엄지용(Jeeyong Um) 문관경(Gwan-gyeong Mun) 신현수(Hyunsu Shin) 성대현(DaeHyun Sung)    아직도 한글화할 부분이 많습니다. 참여를 원하는 분은 아래 프로젝트 페이지를 방문하시기 바랍니다.\n https://l10n.gnome.org/teams/ko/  "});})();